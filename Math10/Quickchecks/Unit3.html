<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Unit 2 Quick Check </title>
  <style>
    :root{
      --bg:#fbfaf8; --panel:#ffffff; --ink:#161616;
      --muted:#5f616d; --border:#ece7df;
      --brand:#2563eb; --good:#15803d;
    }
  
    /* Base */
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--ink);
      font:15px/1.45 "KaTeX_Main","Latin Modern Roman","Computer Modern",
                       "STIX Two Text","Times New Roman",serif;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }
  
    /* Frame */
    .container{max-width:880px; margin:0 auto; padding:16px}
    header{
      display:flex; flex-wrap:wrap; align-items:flex-end; justify-content:space-between;
      gap:8px; margin-bottom:12px
    }
    header h1{margin:0; font-size:clamp(18px,2.4vw,22px); letter-spacing:.2px}
    header .sub{color:var(--muted); font-size:12px}
    .toolbar{display:flex; gap:8px; flex-wrap:wrap}
    button{
      border:1px solid var(--border); background:#fff;
      padding:7px 10px; border-radius:10px; cursor:pointer; font-size:13px
    }
    button.brand{background:#eef3ff; border-color:#d8e2ff; color:#0c2a7a; font-weight:600}
  
    /* Cards / sections */
    .card{
      background:var(--panel); border:1px solid var(--border);
      border-radius:12px; padding:14px 16px;
      box-shadow:0 1px 6px rgba(0,0,0,.04); margin-bottom:12px
    }
    .card h2{margin:0 0 6px 0; font-size:16px}
    .kicker{
      color:var(--muted); font-size:11px; text-transform:uppercase;
      letter-spacing:.35px; margin-bottom:6px
    }
    .divider{
      height:1px; margin:8px 0;
      background:linear-gradient(90deg, transparent, var(--border), transparent)
    }
  
    /* Question rows */
    .card > div{margin:6px 0}
    .mc-choices{
      display:grid; gap:6px; margin-top:6px;
      grid-template-columns:repeat(auto-fit,minmax(180px,1fr));
    }
    @media (min-width:700px){ .mc-choices{grid-template-columns:repeat(2,1fr)} }
    @media (min-width:1000px){ .mc-choices{grid-template-columns:repeat(4,1fr)} }
  
    .choice{
      display:flex; gap:6px; align-items:flex-start;
      border:1px dashed var(--border); border-radius:8px;
      padding:6px 8px; background:#fff; font-size:14px
    }
  
    /* Answers */
    .ans{color:var(--good); font-weight:600; margin-top:6px; font-size:14px}
    .ans[hidden]{display:none!important}
  
    /* Answer key: hidden on screen, shown only when printing */
    #answerKey{display:none}
  
    /* hide answer key on screen */
#answerKey {
  display: none;
}

  /* Print */
  @media print {
    .toolbar { display: none }
    body { background:#fff }
    .card { box-shadow:none }
  
    /* hide inline answers in quiz */
    .ans { display:none !important }
  
    /* show compiled answer key on a new page */
    #answerKey {
      display:block;
      page-break-before:always;
      font-size:14px;
      padding:0 8px;
    }
  
    #answerKey h2 {
      margin:0 0 8px 0;
      font-size:16px;
    }
  
    #answerKey .ansItem {
      margin:4px 0;
    }
  }


    
  </style>


  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.css">
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Unit 2 Quick Check</h1>
        <div class="sub">Math with Mr. Merrick ‚Ä¢ Math 10</div>
      </div>
      <div class="toolbar">
        <button id="generate" class="brand">üîÄ Generate New Version</button>
        <button id="toggleKey" aria-pressed="false">üß† Show Answers</button>
        <button id="printBtn">üñ®Ô∏è Print</button>
      </div>
    </header>

    <div id="quiz"></div>
    <div id="answerKey"></div>
  </div>

  <script>
    function shuffle(arr){ for(let i=arr.length-1;i>0;i--){ const j=Math.floor(Math.random()*(i+1)); [arr[i],arr[j]]=[arr[j],arr[i]]; } return arr; }
    function typeset(el){ if(window.renderMathInElement){ window.renderMathInElement(el,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false}],throwOnError:false}); } }

    const BANK = [
      {
        title: 'A. Multiple Choice',
        note: 'Select one option.',
        items: [
          { type: 'mcgen', gen: genU2_SimplifyQuotientPowers },
          { type: 'mcgen', gen: genU2_NegExpInverse },
          { type: 'mcgen', gen: genU2_SciMultiply },
          { type: 'mcgen', gen: genU2_SciDivide },
          { type: 'mcgen', gen: genU2_RationalExpEvaluate },
          { type: 'mcgen', gen: genU2_SimplifyRadicalXY },
          { type: 'mcgen', gen: genU2_SingleRadicalCombine },
          { type: 'mcgen', gen: genU2_ImproperSci },
          { type: 'mcgen', gen: genU2_NegExpSimplify },
          { type: 'mcgen', gen: genU2_PowerOfPower }
        ]},

      {
        title: 'B. Numeric Response',
        note: 'Write your final answer clearly in the box.',
        items: [
          { type: 'gen', gen: genNR_U2_RationalExp },
          { type: 'gen', gen: genNR_U2_SciAdd },
          { type: 'gen', gen: genNR_U2_SciDivide },
          { type: 'gen', gen: genNR_U2_RationalExpNegative },
          { type: 'gen', gen: genNR_U2_SolveExponentEquation },
          { type: 'gen', gen: genNR_U2_SciCompound }
        ]},

      {
        title: 'C. Written Response',
        note: 'Show full reasoning; write answers with positive exponents and/or radicals.',
        items: [
          { type: 'gen', gen: genWR_U2_SimplifyMonomialQuotient },
          { type: 'gen', gen: genWR_U2_SciProductExplain },
          { type: 'gen', gen: genWR_U2_FracPowersToRadicals },
          { type: 'gen', gen: genWR_U2_RootOfPerfects },
          { type: 'gen', gen: genWR_U2_OrderNumbers },
          { type: 'gen', gen: genWR_U2_SolveRationalExponentEq },
          { type: 'gen', gen: genWR_U2_MicroArea },
          { type: 'gen', gen: genWR_U2_SimplifyFracPowers },
          { type: 'gen', gen: genWR_U2_SolveSplitBases },
          { type: 'gen', gen: genWR_U2_PrimePowerSystem },
          { type: 'gen', gen: genWR_U2_PowerModel },
          { type: 'gen', gen: genWR_U2_Diophantine1 },
          { type: 'gen', gen: genWR_U2_CompositionIdentity },
          { type: 'gen', gen: genWR_U2_MixedBaseSolve }
        ]}

    ];

    const quizEl = document.getElementById('quiz');

    // ---------- MC helper utilities ----------
    const ri = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;     // random int in [a,b]
    const sample = (arr)=>arr[ri(0,arr.length-1)];

    // exact square extraction: n = s^2 * m  (m squarefree)
    function extractSquare(n){
      let s = 1, m = n, d = 2;
      while (d*d <= m){
        while (m % (d*d) === 0){ s *= d; m /= d*d; }
        d++;
      }
      return { s, m };
    }
    // arithmetic series sum of multiples of k on [L,U]
    function sumMultiples(k, L, U){
      const a1 = Math.ceil(L/k)*k, an = Math.floor(U/k)*k;
      if (a1 > an) return 0;
      const n = Math.floor((an - a1)/k) + 1;
      return n * (a1 + an) / 2;
    }

    function genWR_SimplifyMonomialRoot(){
      const K = ri(30,150);
      const a = ri(2,8), b = ri(2,8);
      const outX = Math.floor(a/2), outY = Math.floor(b/2);
      const remX = a%2, remY = b%2;
      const { s, m } = extractSquare(K);
      const outsideParts = [];
      if (s>1) outsideParts.push(String(s));
      if (outX>0) outsideParts.push(`x^{${outX}}`);
      if (outY>0) outsideParts.push(`y^{${outY}}`);
      const insideParts = [];
      if (m>1) insideParts.push(String(m));
      if (remX) insideParts.push('x');
      if (remY) insideParts.push('y');
      const outside = outsideParts.join('');
      const inside = insideParts.length ? `\\sqrt{${insideParts.join('\\,')}}` : '';
      const ans = outside && inside ? `${outside}${inside}` : (inside || outside || '1');
    
      return {
        q: `Simplify $\\sqrt{${K}\\,x^{${a}}y^{${b}}}$ for $x,y\\ge 0$.`,
        answer: `$${ans}$`
      };
    }

    

    function genWR_RationalizeSimple(){
      // choose N with a square factor and C so it reduces nicely
      const N = ri(18,80);
      const C = ri(4,18);
      const { s, m } = extractSquare(N);  // sqrt(N)=s*sqrt(m)
      // c/sqrt(N) = c*s*sqrt(m)/N -> reduce rational factor
      const num = C*s, den = N;
      const g = gcd(num, den);
      const num2 = num/g, den2 = den/g;
      const ans = m===1 ? `\\dfrac{${num2}}{${den2}}` : `\\dfrac{${num2}\\sqrt{${m}}}{${den2}}`;
    
      return {
        q: `Rationalize and simplify: $\\dfrac{${C}}{\\sqrt{${N}}}$.`,
        answer: `$${ans}$`
      };
    }

    function genWR_RepeatingToFraction(){
      const I = ri(1,12);                // integer part
      const r = sample([1,2]);           // period length
      const d1 = ri(1,9), d2 = ri(0,9);
      const R = r===1 ? d1 : (10*d1 + d2);
      const pow = r===1 ? 10 : 100;      // 10^r
      const denom = pow - 1;
      const num = I*denom + R;           // I + R/(10^r-1) => (I(10^r-1)+R)/(10^r-1)
      const g = gcd(num, denom);
      const numS = (num/g), denS = (denom/g);
    
      return {
        q: `Convert $${I}.\\overline{${r===1? d1 : `${d1}${d2}`}}$ to a fraction in simplest form.`,
        answer: `$\\dfrac{${numS}}{${denS}}$`
      };
    }

    function genWR_CuberootNegative(){
      const a = ri(6,20);
      return {
        q: `Evaluate $\\sqrt[3]{-${a}^3}$.`,
        answer: `$-${a}$`
      };
    }

    function genWR_PrimeFactorizePairGcdLcm(){
      // Build two numbers from small primes; ensure not both share all primes
      const primes=[2,3,5,7,11,13,17,19];
      function build(){
        const ps = shuffle(primes.slice(0,5)).slice(0,ri(1,3));
        let n=1, f={};
        ps.forEach(p=>{
          const e=ri(1,2);
          f[p]=e; n*=p**e;
        });
        return {n,f};
      }
      let A=build(), B=build();
      // avoid identical numbers
      if (A.n===B.n) B=build();
    
      function fmt(f){
        return Object.keys(f).sort((a,b)=>a-b).map(p=>{
          const e=f[p]; return e===1? `${p}` : `${p}^{${e}}`;
        }).join('\\cdot ');
      }
      // compute gcd/lcm from factorizations
      const allP = Array.from(new Set([...Object.keys(A.f),...Object.keys(B.f)])).map(Number).sort((x,y)=>x-y);
      let g=1, L=1;
      allP.forEach(p=>{
        const eA=A.f[p]||0, eB=B.f[p]||0;
        const eg=Math.min(eA,eB), eL=Math.max(eA,eB);
        if(eg>0) g*=p**eg;
        if(eL>0) L*=p**eL;
      });
    
      return {
        q: `Prime factorize ${A.n} and ${B.n}. Hence determine $\\gcd$ and $\\mathrm{lcm}$.`,
        answer: `$${A.n}=${fmt(A.f)},\\ \\ ${B.n}=${fmt(B.f)};\\ \\ \\gcd=${g},\\ \\mathrm{lcm}=${L}$`
      };
    }

    function genWR_PerfectCubeAdjustment(){
      const a=ri(0,3), b=ri(0,3), c=ri(0,3), d=ri(0,3);
      const isSquare = (a%2===0)&&(b%2===0)&&(c%2===0)&&(d%2===0);
      const isCube   = (a%3===0)&&(b%3===0)&&(c%3===0)&&(d%3===0);
      // minimal exponents to reach multiples of 3
      const need = e => (3 - (e%3))%3;
      const ma=need(a), mb=need(b), mc=need(c), md=need(d);
      const parts=[];
      if(ma) parts.push(`2^{${ma}}`);
      if(mb) parts.push(`3^{${mb}}`);
      if(mc) parts.push(`5^{${mc}}`);
      if(md) parts.push(`7^{${md}}`);
      const m = parts.length? parts.join('\\cdot ') : '1';
    
      return {
        q: `Let $N=2^{${a}}\\cdot 3^{${b}}\\cdot 5^{${c}}\\cdot 7^{${d}}$. Decide whether $N$ is a perfect square and/or a perfect cube. If not a cube, find the least positive integer $m$ so that $Nm$ is a perfect cube.`,
        answer: `${isSquare? 'Square: yes':'Square: no'}, ${isCube? 'Cube: yes':'Cube: no'}, $m=${m}$`
      };
    }


    function genWR_SimplifyRadicalFraction(){
      // random but safe exponents (no negatives after division)
      const A = ri(20, 40), B = ri(20, 40), C = ri(2, 12);
      let p = ri(1, 3), q = ri(2, 4), r = ri(1, 3), s = ri(1, 3), t = ri(1, 2);
    
      // ensure x exponent stays ‚â• 0 after p+r‚àít
      if (p + r - t < 0) { r += (t - (p + r)); }
    
      // combine numeric coefficients as a reduced fraction
      let num = A * B, den = C;
      const g1 = gcd(num, den); num /= g1; den /= g1;
    
      // pull out perfect squares from numerator/denominator separately
      const { s: sNum, m: mNum } = extractSquare(num);
      const { s: sDen, m: mDen } = extractSquare(den);
    
      // variable exponents
      const xExp = p + r - t, yExp = q + s;
      const xOut = Math.floor(xExp / 2), yOut = Math.floor(yExp / 2);
      const xIn  = xExp % 2,           yIn  = yExp % 2;
    
      // outside factor (numeric fraction * outside vars)
      const outsideNum = (sDen > 1)
        ? `\\dfrac{${sNum}}{${sDen}}`
        : (sNum > 1 ? String(sNum) : '');
      const outsideVars = [
        xOut ? `x^{${xOut}}` : '',
        yOut ? `y^{${yOut}}` : ''
      ].filter(Boolean).join('');
      const outside = [outsideNum, outsideVars].filter(Boolean).join('');
    
      // inside radicand (reduced numeric * leftover vars)
      const insideNum = (mDen > 1)
        ? `\\dfrac{${mNum}}{${mDen}}`
        : (mNum > 1 ? String(mNum) : '');
      const insideParts = [
        insideNum,
        xIn ? 'x' : '',
        yIn ? 'y' : ''
      ].filter(Boolean).join('\\,');
    
      const sqrtPart = insideParts ? `\\sqrt{${insideParts}}` : '';
      let ansCore = `${outside}${sqrtPart}`;
      if (!ansCore) ansCore = '1';
    
      // QUESTION: inline math only ($...$) ‚Äî no \[...\]
      const qTex =
        `Simplify and write with radicals (no negative exponents): ` +
        `$\\dfrac{\\sqrt{${A}x^{${p}}y^{${q}}}\\,\\cdot\\,\\sqrt{${B}x^{${r}}y^{${s}}}}{\\sqrt{${C}x^{${t}}}}\\; (x,y\\ge 0).$`;
    
      return {
        q: qTex,
        answer: `$${ansCore}$`
      };
    }


    function genWR_SumMultiples2or3(){
      let L = ri(100,300), U = ri(700,1200);
      if (L>U) [L,U]=[U,L];
    
      const S2  = sumMultiples(2,L,U);
      const S3  = sumMultiples(3,L,U);
      const S6  = sumMultiples(6,L,U);
      const total = S2 + S3 - S6;
    
      return {
        q: `Find the sum of all integers between $${L}$ and $${U}$ inclusive that are multiples of $2$ or $3$.`,
        answer: `$${total}$ \\; with\\; sums\\; S_2=${S2},\\ S_3=${S3},\\ S_6=${S6}.`
      };
    }

    function genWR_Babylonian(){
      const N = ri(50,150);
      // start at integer guess x0 = floor(sqrt(N)) or a nearby integer
      const x0 = Math.max(1, Math.floor(Math.sqrt(N)));
      const x1 = 0.5*(x0 + N/x0);
      const x2 = 0.5*(x1 + N/x1);
      const approx = Math.round(x2*10000)/10000;
      return {
        q: `Use two iterations to approximate $\\sqrt{${N}}$ correct to four decimal places (start $x_0=${x0}$).`,
        answer: `$x_1=${x1.toFixed(9)},\\ x_2=${x2.toFixed(9)};\\ \\sqrt{${N}}\\approx ${approx.toFixed(4)}$`
      };
    }


    
    
    function isPrime(n){
      if(n<2) return false;
      if(n%2===0) return n===2;
      for(let d=3; d*d<=n; d+=2) if(n%d===0) return false;
      return true;
    }
    
    function randPrime(min=50,max=300){
      let n=ri(min,max);
      while(!isPrime(n)) n=ri(min,max);
      return n;
    }
    
    function randComposite(min=50,max=300){
      let n=ri(min,max);
      while(isPrime(n)) n=ri(min,max);
      return n;
    }
    
    function gcd(a,b){ a=Math.abs(a); b=Math.abs(b);
      while(b){ [a,b]=[b,a%b]; }
      return a;
    }
    function lcm(a,b){ return Math.abs(a*b)/gcd(a,b); }
    
    function primeFactorization(n){
      const f = {};
      let d=2, x=n;
      while(d*d<=x){
        while(x%d===0){ f[d]=(f[d]||0)+1; x/=d; }
        d+= (d===2?1:2);
      }
      if(x>1) f[x]=(f[x]||0)+1;
      return f; // {prime: exp, ...}
    }
    function fmtFactorization(f){
      const parts = Object.keys(f).sort((a,b)=>a-b).map(p=>{
        const e=f[p];
        return e===1? `${p}` : `${p}^{${e}}`;
      });
      return parts.join('\\cdot ');
    }
    
    function squarefree(n){
      const f=primeFactorization(n);
      return Object.values(f).every(e=>e===1);
    }

    function genMC_Prime(){
      const correct = randPrime(100,300);
      const wrongs = new Set();
      while(wrongs.size<3){ wrongs.add(randComposite(90,320)); }
      const choices = [correct, ...wrongs].map(x=>`$${x}$`);
      // shuffle while tracking correct index
      const order = choices.map((_,i)=>i);
      order.sort(()=>Math.random()-0.5);
      const shuffled = order.map(i=>choices[i]);
      const answerIndex = order.indexOf(0);
      return { q:'Which of the following is a prime number?', choices:shuffled, answerIndex };
    }

    function genMC_PrimeFactorization(){
      // build n with small primes
      const primes=[2,3,5,7];
      const exps = primes.map(p=>ri(0,2));
      if(exps.every(e=>e===0)) exps[ri(0,3)]=1; // ensure >1
      let n=1; exps.forEach((e,i)=>{ n*=Math.pow(primes[i],e); });
      const f={}; primes.forEach((p,i)=>{ if(exps[i]>0) f[p]=exps[i]; });
      const correct = `$${fmtFactorization(f)}$`;
    
      // plausible wrongs: tweak one exponent
      const wrongs=[];
      for(let k=0;k<3;k++){
        const g={...f};
        const keys=Object.keys(g);
        if(keys.length===0){ g[2]=1; }
        const pick = sample(keys.length?keys:['2']);
        g[pick] = Math.max(1,(g[pick]||0) + (Math.random()<0.5?-1:1));
        wrongs.push(`$${fmtFactorization(g)}$`);
      }
    
      const choices=[correct,...wrongs];
      const order = choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return {
        q:'The prime factorization of $n$ (given) is',  // you can customize "n" text if desired
        choices: order.map(i=>choices[i]),
        answerIndex: order.indexOf(0)
      };
    }

    function genMC_GCD(){
      const g = sample([1,2,3,4,5,6]);
      const a = g*ri(10,40);
      const b = g*ri(10,40);
      const correct = `$${g}$`;
      const pool=[1,2,3,4,5,6,7,8,9].filter(x=>x!==g);
      const wrongs = shuffle(pool).slice(0,3).map(x=>`$${x}$`);
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q:`$\\gcd(${a},\\,${b})$ equals`, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    function genMC_LCM(){
      let a=ri(6,20), b=ri(6,20);
      const L = lcm(a,b);
      const correct = `$${L}$`;
      const wrongs = [
        `$${a+b}$`, `$${a*b}$`, '$1$'
      ];
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q:`$\\mathrm{lcm}(${a},\\,${b})$ equals`, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    function genMC_PerfectSquare(){
      const primes=[2,3,5];
      const evenExp = ()=>2*ri(1,3);
      const oddExp  = ()=>2*ri(1,3)-1;
    
      const correctParts = primes.map(p=>`${p}^{${evenExp()}}`);
      const correct = `$${correctParts.join('\\cdot ')}$`;
    
      function wrong(){
        const parts = primes.map(p=>`${p}^{${(Math.random()<0.5?oddExp():evenExp())}}`);
        // force at least one odd
        if(parts.every(s=>/^\d+\^\{[02468]\}$/.test(s.replace(/\\cdot/g,'')))){
          const idx=ri(0,2);
          const base=primes[idx];
          parts[idx]=`${base}^{${oddExp()}}`;
        }
        return `$${parts.join('\\cdot ')}$`;
      }
      const choices=[correct, wrong(), wrong(), wrong()];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q:'Which is a perfect square?', choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    function genMC_PerfectCube(){
      const primes=[2,3,5];
      const mult3 = ()=>3*ri(1,3);
      const not3  = ()=>3*ri(1,3)+(Math.random()<0.5?1:2);
    
      const correct = `$${primes.map(p=>`${p}^{${mult3()}}`).join('\\cdot ')}$`;
      const wrong = ()=>`$${primes.map(p=>`${p}^{${not3()}}`).join('\\cdot ')}$`;
    
      const choices=[correct, wrong(), wrong(), wrong()];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q:'Which is a perfect cube?', choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    
    function genMC_EntireRadical(){
      const a = ri(2,9);
      // choose b squarefree to mirror your style
      let b = ri(10,30);
      while(!squarefree(b)) b=ri(10,30);
      const correct = `$\\sqrt{${a*a}\\cdot ${b}}$`;
      const wrongs = [
        `$\\sqrt{${a}\\cdot ${b}}$`,
        `$\\sqrt{${Math.pow(a,3)}\\cdot ${b}}$`,
        `$\\sqrt{${a*b}}$`
      ];
      const q = `Write $${a}\\sqrt{${b}}$ as an entire radical.`;
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }


    // --- Which is a perfect fourth power? ---
    function genMC_FourthPower(){
      const a = ri(2,8);
      const correct = `$${a**4}$`;
      const wrongs = [`$${a**3}$`, `$${a**4 - 1}$`, `$${a**4 + ri(1,5)}$`];
      const choices = [correct, ...wrongs];
      const order = choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return {
        q: 'Which of the following is a perfect fourth power?',
        choices: order.map(i=>choices[i]),
        answerIndex: order.indexOf(0)
      };
    }

    
    function genMC_MixedRadical(){
      // pick n having a square factor
      const k=ri(2,10), r=ri(2,10);
      const n = (k*k)*r;
      const correct = `$${k}\\sqrt{${r}}$`;
      const wrongs = [
        `$${k*r}\\sqrt{1}$`,
        `$${k}\\sqrt{${k*k}}$`,
        `$\\sqrt{${n}}$`
      ];
      const q = `Convert to mixed radical: $\\sqrt{${n}}$`;
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }


    function genMC_SimplifyRootXY(){
      let k = ri(50,120);
      const a = ri(2,8), b = ri(2,8);
      const outX = Math.floor(a/2), outY = Math.floor(b/2);
      const remX = a%2, remY = b%2;
      const insideParts = [String(k)];
      if(remX) insideParts.push('x');
      if(remY) insideParts.push('y');
      const inside = insideParts.join('\\,');
      const outside = [outX?`x^{${outX}}`:null, outY?`y^{${outY}}`:null].filter(Boolean).join('');
      const correct = `$${outside?outside:''}\\sqrt{${inside}}$`.replace('^1','');
    
      const wrongs = [
        `$${outside?outside:''}\\sqrt{${k}}$`,
        `$${outside?outside:''}\\sqrt{${k}\\,y}$`,
        `$\\sqrt{${k}}${outside?outside:''}$`
      ];
      const q = `Simplify $\\sqrt{${k}\\,x^{${a}}y^{${b}}}$ for $x,y\\ge 0$.`;
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    function genMC_CuberootNeg(){
      const a = ri(5,15);
      const correct = `$-${a}$`;
      const wrongs = [`$${a}$`, `$-${a+1}$`, `$-${a-1}$`];
      const q = `$\\sqrt[3]{-${a**3}}$ equals`;
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    function genMC_Irrational(){
      const mns=[2,3,5,6,7,8,10,11,12,13,14,15,17,18,19];
      const irr = `$\\sqrt{${sample(mns)}}$`;
      const rat1 = `$0.\\overline{${ri(1,9)}${ri(1,9)}}$`;
      const rat2 = `$\\dfrac{${ri(2,9)}}{${ri(10,20)}}$`;
      const rat3 = `$${ri(1,9)}.${ri(10,99)}$`;
      const choices = [irr, rat1, rat2, rat3];
      const order = choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q:'Which number is \\emph{irrational}?', choices: order.map(i=>choices[i]), answerIndex: order.indexOf(0) };
    }


    function genMC_SimplifyProductRoots(){
      // choose a,b so ab has a square factor
      const s = [4,9,16,25][ri(0,3)];
      const t = ri(2,12);
      const a = s; const b = t;
      const ab = a*b;
      // fully simplify ‚àöab
      let x=ab, out=1, d=2;
      while(d*d<=x){
        while(x%(d*d)===0){ out*=d; x/=d*d; }
        d++;
      }
      const correct = `$${out>1?out:''}\\sqrt{${x}}$`.replace('^1','');
      const wrongs = [`$\\sqrt{${ab}}$`, `$${out}\\sqrt{${ab}}$`, `$${out>1?out:''}\\sqrt{${a+b}}$`];
      const q = `Simplify $\\sqrt{${a}}\\cdot \\sqrt{${b}}$.`;
      const choices=[correct,...wrongs];
      const order=choices.map((_,i)=>i).sort(()=>Math.random()-0.5);
      return { q, choices:order.map(i=>choices[i]), answerIndex:order.indexOf(0) };
    }

    // ---------- Numeric Response generators ----------

    // NR1: gcd(a,b) where gcd is guaranteed and non-trivial
    function genNR_GCD(){
      // pick target gcd g and coprime multipliers u,v so gcd(gu, gv) = g
      const g = ri(2, 12);
      let u = ri(10, 60), v = ri(10, 60);
      // force coprime u,v
      while (gcd(u, v) !== 1) { u = ri(10, 60); v = ri(10, 60); }
      const a = g * u, b = g * v;
    
      return {
        q: `Calculate $\\gcd(${a},\\,${b})$.`,
        answer: `$${g}$`
      };
    }
    
    // NR2: lcm of three integers where each is a divisor of a constructed L, so lcm(a,b,c)=L
    function genNR_LCM3(){
      // Build an L from small prime exponents
      const e2 = ri(1,3), e3 = ri(0,2), e5 = ri(0,2), e7 = ri(0,2);
      const L = (2**e2) * (3**e3) * (5**e5) * (7**e7);
    
      // Helper to pick a divisor by lowering exponents randomly
      function pickDiv(){
        const f2 = ri(0, e2), f3 = ri(0, e3), f5 = ri(0, e5), f7 = ri(0, e7);
        return (2**f2) * (3**f3) * (5**f5) * (7**f7);
      }
      // Ensure not all equal tiny numbers; regenerate if too small/duplicate
      let a = pickDiv(), b = pickDiv(), c = pickDiv();
      for(let tries=0; tries<10 && new Set([a,b,c]).size<3; tries++){ a = pickDiv(); b = pickDiv(); c = pickDiv(); }
    
      return {
        q: `Calculate $\\mathrm{lcm}(${a},\\,${b},\\,${c})$.`,
        answer: `$${L}$`
      };
    }
    
    // NR3: Sum of exponents a+b+c+d when N is given as a numeric value with known prime exponents
    function genNR_SumPrimeExponents(){
      // choose exponents (allow 0 for variety, but not all zero)
      let a = ri(0,3), b = ri(0,3), c = ri(0,3), d = ri(0,3);
      if (a+b+c+d === 0) { // ensure not all zero
        const slot = ri(0,3);
        if (slot===0) a = 1; else if (slot===1) b = 1; else if (slot===2) c = 1; else d = 1;
      }
      const N = (2**a) * (3**b) * (5**c) * (7**d);
      const sum = a + b + c + d;
    
      return {
        q: `Let the prime factorization of $${N}$ be $2^{a}\\cdot 3^{b}\\cdot 5^{c}\\cdot 7^{d}$. Compute $a+b+c+d$.`,
        answer: `$${sum}$`
      };
    }


    function renderQuiz(){
      // reset quiz and answer key
      quizEl.innerHTML = '';
      const keyEl = document.getElementById('answerKey');
      if (keyEl) keyEl.innerHTML = '';
    
      let qCounter = 1;
      const ansItems = []; // lines for the printed Answer Key
    
      BANK.forEach(sec=>{
        const card = document.createElement('div');
        card.className = 'card';
        // NOTE: BANK uses "title", not "section"
        card.innerHTML = `<h2>${sec.title || sec.section || ''}</h2>` +
                         `<div class="divider"></div>`;
    
        sec.items.forEach(item=>{
          // --- Legacy fixed MC (if any remain) ---
          if (item.type === 'mc') {
            const shuffled = shuffle(item.choices.slice());
            const opts = shuffled.map((c,i)=>{
              const letter = String.fromCharCode(65+i);
              return `<div class="choice">(${letter}) <span class="math">${c}</span></div>`;
            }).join('');
    
            card.innerHTML +=
              `<div><strong>${qCounter}. </strong><span class="math">${item.q}</span></div>`+
              `<div class="mc-choices">${opts}</div>`+
              `<div class="ans math" hidden>Answer: ${item.answer}</div>`;
    
            ansItems.push(`<div class="ansItem"><strong>${qCounter}.</strong> <span class="math">${item.answer}</span></div>`);
            qCounter++;
          }
    
          // --- Generator-based Multiple Choice ---
          else if (item.type === 'mcgen') {
            let q, choices, answerIndex;
            try {
              ({ q, choices, answerIndex } = item.gen());
            } catch {
              q = 'Problem unavailable.'; choices = ['$A$','$B$','$C$','$D$']; answerIndex = 0;
            }
    
            const opts = choices.map((c,i)=>{
              const letter = String.fromCharCode(65+i);
              return `<div class="choice">(${letter}) <span class="math">${c}</span></div>`;
            }).join('');
    
            const correct = choices[answerIndex];
    
            card.innerHTML +=
              `<div><strong>${qCounter}. </strong><span class="math">${q}</span></div>`+
              `<div class="mc-choices">${opts}</div>`+
              `<div class="ans math" hidden>Answer: ${correct}</div>`;
    
            ansItems.push(`<div class="ansItem"><strong>${qCounter}.</strong> <span class="math">${correct}</span></div>`);
            qCounter++;
          }
    
          // --- Generator-based numeric/written (returns {q, answer}) ---
          else if (item.type === 'gen') {
            let generated = { q:'Problem unavailable.', answer:'' };
            try { generated = item.gen(); } catch {}
            const { q, answer } = generated;
    
            card.innerHTML +=
              `<div><strong>${qCounter}. </strong><span class="math">${q}</span></div>`+
              `<div class="ans math" hidden>Answer: ${answer}</div>`;
    
            ansItems.push(`<div class="ansItem"><strong>${qCounter}.</strong> <span class="math">${answer}</span></div>`);
            qCounter++;
          }
    
          // --- Fallback for fixed text items (numeric/written) if any remain ---
          else {
            card.innerHTML +=
              `<div><strong>${qCounter}. </strong><span class="math">${item.q || ''}</span></div>`+
              `<div class="ans math" hidden>Answer: ${item.answer || ''}</div>`;
            ansItems.push(`<div class="ansItem"><strong>${qCounter}.</strong> <span class="math">${item.answer || ''}</span></div>`);
            qCounter++;
          }
        });
    
        quizEl.appendChild(card);
      });
    
      // Build the printed Answer Key content
      if (keyEl) {
        keyEl.innerHTML = `<h2>Answer Key</h2>${ansItems.join('')}`;
      }
    
      // Typeset math in both quiz and key
      typeset(quizEl);
      if (keyEl) typeset(keyEl);
    }






    function randomDivisorQuestion(){
      const n = Math.floor(Math.random()*900+100); // random 100‚Äì999
      // compute divisor count
      let count=1, num=n, d=2;
      while(num>1){
        let exp=0;
        while(num%d===0){ num/=d; exp++; }
        if(exp>0) count*=(exp+1);
        d++;
        if(d*d>num){ if(num>1){count*=2; break;} }
      }
      return {
        q: `Find the number of positive divisors of $${n}$.`,
        answer: `${count}`
      };
    }

    function randomMultiplesQuestion(){
      const N = Math.floor(Math.random()*1000+500); // between 500 and 1500
      const count = Array.from({length:N},(_,i)=>i+1)
        .filter(k=>(k%3===0||k%4===0)&&k%5!==0).length;
      return {
        q: `How many positive integers $<${N}$ are multiples of $3$ or $4$ but not $5$?`,
        answer: `${count}`
      };
    }

    function randomSetQuestion(){
      // choose an upper bound multiple of 5 between 500‚Äì2500
      const N = Math.floor(Math.random()*1000+1500);  
      // sums with formulas
      const nA = Math.floor(N/5);
      const sumA = 5*nA*(nA+1)/2;
    
      const nAB = Math.floor(N/10);
      const sumAB = 10*nAB*(nAB+1)/2;
    
      const nB = Math.floor(N/2);
      const sumB = 2*nB*(nB+1)/2;
    
      const sumAorB = sumA + sumB - sumAB;
    
      // (iv) count (B‚à©C)\A: multiples of 6 not multiples of 5
      const countBC = Math.floor(N/6);
      const countBCnotA = Array.from({length:countBC},(_,i) => (i+1)*6)
        .filter(x => x%5 !== 0).length;
    
      // (v) sum of B not (A‚à™C): multiples of 2, exclude 5 or 3
      const sumBnot = Array.from({length:nB},(_,i) => (i+1)*2)
        .filter(x => x%3 !== 0 && x%5 !== 0)
        .reduce((a,b) => a+b, 0);
    
      return {
        q: `Let $A=\\{\\text{multiples of 5} \\le ${N}\\}$, \
    $B=\\{\\text{multiples of 2} \\le ${N}\\}$, \
    $C=\\{\\text{multiples of 3} \\le ${N}\\}$.<br>\
    (i) $\\sum A$<br>\
    (ii) $\\sum(A\\cap B)$<br>\
    (iii) $\\sum(A\\cup B)$<br>\
    (iv) $|(B\\cap C)\\setminus A|$<br>\
    (v) $\\sum(B\\setminus(A\\cup C))$`,
        answer:`(i) ${sumA}, (ii) ${sumAB}, (iii) ${sumAorB}, (iv) ${countBCnotA}, (v) ${sumBnot}`
      };
    }
    
    function randomDivisors360Question(){
      // keep base number fixed at 360 but randomize asked properties
      const divisors=[1,2,3,4,5,6,8,9,10,12,15,18,20,24,30,36,40,45,60,72,90,120,180,360];
      const total=divisors.length;
    
      const even=divisors.filter(x=>x%2===0).length;
      const mult4=divisors.filter(x=>x%4===0).length;
      const mult9=divisors.filter(x=>x%9===0).length;
    
      const ans1=`${even}/${total}`;
      const ans2=`(${mult4}/${total})^2`;
      const ans3=`(${mult9}/${total})*(${mult9-1}/${total-1})`;
      const ans4=`1-(${total-even}/${total})^2`;
    
      return {
        q:`List all positive divisors of $360$. Then compute:<br>\
    (i) $P(\\text{even})$<br>\
    (ii) With replacement, both multiples of $4$<br>\
    (iii) Without replacement, both multiples of $9$<br>\
    (iv) With replacement, at least one multiple of $2$`,
        answer:`(i) ${ans1}, (ii) ${ans2}, (iii) ${ans3}, (iv) ${ans4}`
      };
    }


    function randomNumberSystemsInclusions(){
      // helpers
      const gcd=(a,b)=>b?gcd(b,a%b):Math.abs(a);
      const nonsquares=[2,3,5,6,7,8,10,11,12,13,14,15,17,18,19,21,22,23,26,27];
    
      // a) proper fraction p/q (reduced), 0<p<q  -> in Q, R
      let p = Math.floor(Math.random()*8)+1;       // 1..9
      let q = Math.floor(Math.random()*9)+2;       // 2..10
      if(p>=q){ [p,q]=[1,3]; }                     // ensure proper
      const g1=gcd(p,q); p/=g1; q/=g1;
    
      // b) terminating decimal with 1‚Äì3 places but not an integer -> in Q, R
      const places = Math.floor(Math.random()*3)+1; // 1..3
      const intPart = Math.floor(Math.random()*9);  // 0..8
      const fracPart = Math.floor(Math.random()*(10**places-1))+1; // not all zeros
      const bStr = `${intPart}.${String(fracPart).padStart(places,'0')}`;
    
      // c) negative integer -> in Z, Q, R (not N or W)
      const cVal = -(Math.floor(Math.random()*9)+2); // -2..-10
    
      // d) natural number (by your convention N={1,2,3,...}) -> in N, W, Z, Q, R
      const dVal = Math.floor(Math.random()*20)+1;   // 1..20
    
      // e) irrational: sqrt of non-square -> in R only
      const m = nonsquares[Math.floor(Math.random()*nonsquares.length)];
    
      // Build prompt (i)‚Äì(v) on separate lines
      const qText =
        `For each value, state all sets it belongs to among $\\mathbb{N},\\mathbb{W},\\mathbb{Z},\\mathbb{Q},\\mathbb{R}$.<br>`+
        `(i) $a=\\dfrac{${p}}{${q}}$<br>`+
        `(ii) $b=${bStr}$<br>`+
        `(iii) $c=${cVal}$<br>`+
        `(iv) $d=${dVal}$<br>`+
        `(v) $e=\\sqrt{${m}}$`;
    
      // Membership strings
      const N='\\mathbb{N}', W='\\mathbb{W}', Z='\\mathbb{Z}', Q='\\mathbb{Q}', R='\\mathbb{R}';
      const A = `${Q}, ${R}`;                         // proper fraction
      const B = `${Q}, ${R}`;                         // terminating decimal
      const C = `${Z}, ${Q}, ${R}`;                   // negative integer
      const D = `${N}, ${W}, ${Z}, ${Q}, ${R}`;       // natural number
      const E = `${R}`;                               // irrational sqrt
    
      const ansText =
        `(i) $a\\in${A}$; `+
        `(ii) $b\\in${B}$; `+
        `(iii) $c\\in${C}$; `+
        `(iv) $d\\in${D}$; `+
        `(v) $e\\in${E}$`;
    
      return { q: qText, answer: ansText };
    }

    function genTF_SetInclusion(){
      // Uses helpers ri() and sample() you already have.
      const N='\\mathbb{N}', W='\\mathbb{W}', Z='\\mathbb{Z}', Q='\\mathbb{Q}', R='\\mathbb{R}';
    
      const roll = ri(1,10);
      let expr, ans;
    
      switch (roll){
        case 1: { // natural number
          const n = ri(1,20);
          expr = `${n}\\in${N}`;
          ans  = 'True';
          break;
        }
        case 2: { // negative not whole
          const n = -ri(1,20);
          expr = `${n}\\in${W}`;
          ans  = 'False';
          break;
        }
        case 3: { // rational fraction
          const a = ri(1,9), b = ri(2,12);
          expr = `\\frac{${a}}{${b}}\\in${Q}`;
          ans  = 'True';
          break;
        }
        case 4: { // repeating decimal is rational
          const d = ri(1,9);
          expr = `0.\\overline{${d}}\\in${Q}`;
          ans  = 'True';
          break;
        }
        case 5: { // irrational square root
          const m = sample([2,3,5,6,7,10,11,13,14,15,17,19,21,22]);
          expr = `\\sqrt{${m}}\\in${Q}`;
          ans  = 'False';
          break;
        }
        case 6: { // convention: 0 ‚àâ N, 1 ‚àà N
          const n = sample(['0','1']);
          expr = `${n}\\in${N}`;
          ans  = (n === '1') ? 'True' : 'False';
          break;
        }
        case 7: { // subset truths
          expr = `${N}\\subseteq${Z}`;
          ans  = 'True';
          break;
        }
        case 8: {
          expr = `${Q}\\subseteq${Z}`;
          ans  = 'False';
          break;
        }
        case 9: {
          expr = `${Z}\\subseteq${Q}`;
          ans  = 'True';
          break;
        }
        default: {
          expr = `${Q}\\subseteq${R}`;
          ans  = 'True';
        }
      }
    
      return {
        q: `$${expr}$ (True/False)`,  // wrap in $...$ so KaTeX renders
        answer: ans
      };
    }

    function randomDivisorsTrailingZeroQuestion(){
      // pick random number with at least one trailing zero (multiple of 10)
      const base = ri(10,100);  // 10‚Äì100
      const n = base * 10;      // ensures trailing zero
    
      // compute all divisors
      const divisors = [];
      for (let d=1; d<=n; d++){
        if(n % d === 0) divisors.push(d);
      }
      const total = divisors.length;
    
      const even = divisors.filter(x => x % 2 === 0).length;
      const mult4 = divisors.filter(x => x % 4 === 0).length;
      const mult9 = divisors.filter(x => x % 9 === 0).length;
    
      const ans1 = `${even}/${total}`;
      const ans2 = `(${mult4}/${total})^2`;
      const ans3 = `(${mult9}/${total})*(${mult9-1}/${total-1})`;
      const ans4 = `1-(${total-even}/${total})^2`;
    
      return {
        q:`List all positive divisors of $${n}$. Then compute:<br>
    (i) $P(\\text{even})$<br>
    (ii) With replacement, both multiples of $4$<br>
    (iii) Without replacement, both multiples of $9$<br>
    (iv) With replacement, at least one multiple of $2$`,
        answer:`(i) ${ans1}, (ii) ${ans2}, (iii) ${ans3}, (iv) ${ans4}`
      };
    }

        // ---------- Unit 2: Multiple Choice Generators ----------
    // Assumes you already have ri(a,b) and sample(arr). If not, uncomment below.
    // const ri = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    // const sample = (arr)=>arr[ri(0,arr.length-1)];
    
    // 1) Simplify quotient with powers & negatives, then express with positive exponents
    function genU2_SimplifyQuotientPowers(){
      const a = ri(2,5);
      const ex1 = ri(1,4), ey1 = -ri(1,3);
      const ex2 = -ri(1,3), ey2 = ri(2,4);
      const k1 = ri(2,3), k2 = ri(2,3);
      const num = `( ${a}\\,x^{${ex1}}y^{${ey1}} )^{${k1}}`, den = `( x^{${ex2}}y^{${ey2}} )^{${k2}}`;
    
      const coef = a**k1;
      const xExp = ex1*k1 - ex2*k2;
      const yExp = ey1*k1 - ey2*k2;
    
      const numParts = [`${coef}`, xExp>0?`x^{${xExp}}`:'' , yExp>0?`y^{${yExp}}`:''].filter(Boolean);
      const denParts = [xExp<0?`x^{${-xExp}}`:'' , yExp<0?`y^{${-yExp}}`:''].filter(Boolean);
    
      const correct = denParts.length ? `$\\dfrac{${numParts.join('')}}{${denParts.join('')}}$` : `$${numParts.join('')}$`;
      const wrong1 = `$\\dfrac{${coef}}{x^{${Math.abs(xExp)}}y^{${Math.abs(yExp)}}}$`; // drops positive vars
      const wrong2 = `$${coef}x^{${Math.abs(xExp)}}y^{${Math.abs(yExp)}}$`; // forces all positive
      const wrong3 = (()=>{ // adds exponents instead of subtracting on division
        const xx = ex1*k1 + ex2*k2, yy = ey1*k1 + ey2*k2;
        const np = [`${coef}`, xx>0?`x^{${xx}}`:'', yy>0?`y^{${yy}}`:''].filter(Boolean);
        const dp = [xx<0?`x^{${-xx}}`:'', yy<0?`y^{${-yy}}`:''].filter(Boolean);
        return dp.length? `$\\dfrac{${np.join('')}}{${dp.join('')}}$` : `$${np.join('')}$`;
      })();
    
      const q = `Simplify $\\displaystyle \\frac{${num}}{${den}}$ (write with positive exponents).`;
      const choices=[correct, wrong1, wrong2, wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 2) Inverse from negative exponents
    function genU2_NegExpInverse(){
      const a = ri(1,3), b = ri(1,3), c = ri(1,3);
      const q = `Which equals $\\dfrac{1}{(a^{- ${ri(2,3)}}b^{${ri(1,3)}})^{-1}c^{-2}}$ for $a,b,c\\ne 0$?`;
      // Fix one deterministic variant to match Unit 2 vibe:
      const correct = `$\\dfrac{b^{2}c^{2}}{a^{3}}$`;
      const wrongs  = [`$\\dfrac{a^{3}}{b^{2}c^{2}}$`, `$a^{-3}b^{2}c^{-2}$`, `$\\dfrac{b^{-2}}{a^{3}c^{2}}$`];
      const choices=[correct,...wrongs].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 3) Scientific notation ‚Äî multiplication (normalized)
    function genU2_SciMultiply(){
      const A = (ri(12,95)/10), B = (ri(12,95)/10);
      const m = ri(-6,6), n = ri(-6,6);
      let M = A*B, E = m+n;
      while(M>=10){ M/=10; E++; }
      while(M<1){ M*=10; E--; }
      const correct = `$${M.toFixed(2)}\\times 10^{${E}}$`;
      const wrong1  = `$${(A*B).toFixed(2)}\\times 10^{${m+n}}$`; // unnormalized
      const wrong2  = `$${(M*10).toFixed(2)}\\times 10^{${E-1}}$`; // place shift error
      const wrong3  = `$${(M/10).toFixed(2)}\\times 10^{${E+1}}$`;
      const q = `Compute $(${A.toFixed(2)}\\times 10^{${m}})(${B.toFixed(2)}\\times 10^{${n}})$ in scientific notation.`;
      const choices=[correct,wrong1,wrong2,wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 4) Scientific notation ‚Äî division (normalized)
    function genU2_SciDivide(){
      const A = (ri(11,99)/100), B = (ri(12,95)/10);
      const m = ri(-8,-3), n = ri(-2,6);
      let M = A/B, E = m-n;
      while(M>=10){ M/=10; E++; }
      while(M<1){ M*=10; E--; }
      const correct = `$${M.toFixed(2)}\\times 10^{${E}}$`;
      const wrong1  = `$${(A/B).toFixed(2)}\\times 10^{${m-n}}$`; // unnormalized
      const wrong2  = `$${(M*10).toFixed(2)}\\times 10^{${E-1}}$`;
      const wrong3  = `$${(M/10).toFixed(2)}\\times 10^{${E+1}}$`;
      const q = `Compute $\\dfrac{${A.toFixed(2)}\\times 10^{${m}}}{${B.toFixed(1)}\\times 10^{${n}}}$ in scientific notation.`;
      const choices=[correct,wrong1,wrong2,wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 5) Evaluate rational exponent like (32)^{3/5}
    function genU2_RationalExpEvaluate(){
      const b = sample([8,27,32,64,125,216]); // nice perfect powers
      const k = sample([1,2,3]); // numerator
      // choose root r so b is a perfect r-th power
      const baseMap = {8:3,27:3,32:5,64:6,125:3,216:3}; // minimal prime-power info
      let r = baseMap[b]; if (b===64) r = sample([3,6]); // 64 can be 2^6 or 4^3
      const q = `$(${b})^{${k}/${r}}$ equals`;
      const trueVal = Math.round((b**(k/r)));
      const correct = `$${trueVal}$`;
      const wrong1  = `$${b}^{${r}/${k}}$`;
      const wrong2  = `$${Math.pow(Math.round(b**(1/r)), k-1)}$`;
      const wrong3  = `$${Math.round((b**(1/r))*k)}$`;
      const choices=[correct,wrong1,wrong2,wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 6) Simplify radical with variables (positive exponents; x,y >= 0)
    function genU2_SimplifyRadicalXY(){
      const K = ri(20,120);
      const ax = ri(2,8), ay = ri(2,8);
      const outX = Math.floor(ax/2), outY = Math.floor(ay/2);
      const remX = ax%2, remY = ay%2;
    
      // pull perfect square from K
      let s=1, m=K, d=2;
      while(d*d<=m){ while(m%(d*d)===0){ s*=d; m/=d*d; } d++; }
    
      const outside = [s>1?`${s}`:'', outX?`x^{${outX}}`:'', outY?`y^{${outY}}`:''].filter(Boolean).join('');
      const insideParts = []; if(m>1) insideParts.push(`${m}`); if(remX) insideParts.push('x'); if(remY) insideParts.push('y');
      const rad = insideParts.length? `\\sqrt{${insideParts.join('\\,')}}` : '';
      const correct = `$${outside}${rad || ''}$`.replace('^1','');
    
      const wrong1 = `$${outside}\\sqrt{${K}}$`;
      const wrong2 = `$\\sqrt{${K}\\,x^{${ax}}y^{${ay}}}$`;
      const wrong3 = `$${outside}\\sqrt{${m}${remY?'\\,y':''}}$`;
    
      const q = `Simplify $\\sqrt{${K}\\,x^{${ax}}y^{${ay}}}$ for $x,y\\ge 0$.`;
      const choices=[correct,wrong1,wrong2,wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 7) Write a product of fractional powers as a single radical
    function genU2_SingleRadicalCombine(){
      const a = ri(2,7), b = ri(2,7);
      const numA = ri(2,5), numB = ri(1,4), den = ri(2,5);
      const q = `Write $a^{${numA}/${den}}\\,b^{${numB}/${den}}$ as a single radical ($a,b\\ge 0$).`;
      const correct = `$\\sqrt[${den}]{a^{${numA}}b^{${numB}}}$`;
      const wrong1  = `$\\sqrt{a^{${numA}}b^{${numB}}}$`;
      const wrong2  = `$\\sqrt[${numA}]{a^{${den}}}\\,\\sqrt[${numB}]{b^{${den}}}$`;
      const wrong3  = `$\\sqrt[${den}]{ab}$`;
      const choices=[correct,wrong1,wrong2,wrong3].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 8) Identify improper scientific notation
    function genU2_ImproperSci(){
      const n1=`$9.99\\times 10^{0}$`;
      const n2=`$1.01\\times 10^{9}$`;
      const n3=`$12.0\\times 10^{-4}$`; // improper
      const n4=`$6.2\\times 10^{-3}$`;
      const choices=[n1,n2,n3,n4].sort(()=>Math.random()-0.5);
      return { q:'Which is NOT in proper scientific notation?', choices, answerIndex: choices.indexOf(n3) };
    }
    
    // 9) Simplify expression with mixed signed fractional exponents
    function genU2_NegExpSimplify(){
      const q = `Simplify $\\dfrac{x^{1/2}y^{-1}z^{3}}{x^{-3/2}y^{2}z^{-1}}$.`;
      const correct = `$\\dfrac{x^{2}z^{4}}{y^{3}}$`;
      const wrongs = [
        `$\\dfrac{xz^{2}}{y^{3}}$`,
        `$\\dfrac{x^{2}}{yz^{4}}$`,
        `$\\dfrac{x^{2}y^{3}}{z^{4}}$`
      ];
      const choices=[correct,...wrongs].sort(()=>Math.random()-0.5);
      return { q, choices, answerIndex: choices.indexOf(correct) };
    }
    
    // 10) Power of a power with radicals (e.g., (27 a^9 b^6)^{2/3})
    // MC: Power of a power with fractional exponent (assume a,b>0)
    function genU2_PowerOfPower(){
      // Choose a clean q-th power coefficient so no numeric leftovers inside
      const q = sample([3,4,5]);
      const p = sample([1,2,3].filter(t => t < 2*q)); // reasonable numerators
      const k = sample([2,3]);              // small base
      const coef = k ** q;                   // perfect q-th power ‚Üí (coef)^{p/q} = k^p
    
      // Variable exponents: q*n + r (so some leftovers may remain inside)
      const nA = ri(2,5), rA = ri(0,q-1);
      const nB = ri(2,4), rB = ri(0,q-1);
      const aTot = q*nA + rA;
      const bTot = q*nB + rB;
    
      // Outside exponents after ( )^{p/q}
      const outCoef = k ** p;
      const aOut = Math.floor((p * aTot) / q);
      const bOut = Math.floor((p * bTot) / q);
    
      // Inside remainders
      const aRem = (p * aTot) % q;
      const bRem = (p * bTot) % q;
    
      // Build LaTeX pieces
      const qText = `$(${coef}\\,a^{${aTot}}b^{${bTot}})^{${p}/${q}}$`;
    
      const outsideParts = [
        outCoef > 1 ? `${outCoef}` : '',
        aOut ? `a^{${aOut}}` : '',
        bOut ? `b^{${bOut}}` : ''
      ].filter(Boolean).join('');
    
      const insideParts = [];
      if (aRem) insideParts.push(`a^{${aRem}}`);
      if (bRem) insideParts.push(`b^{${bRem}}`);
    
      const radical = insideParts.length ? `\\sqrt[${q}]{${insideParts.join('\\,')}}` : '';
    
      const correct = `$${outsideParts}${radical}$`.replace('^1','');
    
      // Plausible distractors:
      // 1) Forgot to divide exponents by q (applied only ^p)
      const wrong1 = `$${(k**p)}\\,a^{${p*aTot}}b^{${p*bTot}}$`;
    
      // 2) Kept everything under a q-th root (no extracting)
      const wrong2 = `$\\sqrt[${q}]{${(coef**p)}\\,a^{${p*aTot}}b^{${p*bTot}}}$`;
    
      // 3) Dropped the inside remainders entirely
      const wrong3 = `$${(k**p)}${aOut?`a^{${aOut}}`:''}${bOut?`b^{${bOut}}`:''}$`;
    
      const choices = [correct, wrong1, wrong2, wrong3].sort(()=>Math.random()-0.5);
      return {
        q: `Simplify ${qText} (assume $a,b>0$).`,
        choices,
        answerIndex: choices.indexOf(correct)
      };
    }


        // ---------- Unit 2: Numeric Response Generators ----------
    // Uses your existing ri(a,b). If missing, uncomment:
    // const ri = (a,b)=>Math.floor(Math.random()*(b-a+1))+a;
    
    // helper: normalize mantissa/exponent to [1,10)
    function normSci(m, e){
      let M = m, E = e;
      while (M >= 10) { M /= 10; E++; }
      while (M < 1)   { M *= 10; E--; }
      return { M, E };
    }
    
    // NR1: Evaluate (perfect-power)^{p/q}
    function genNR_U2_RationalExp(){
      const c = ri(2, 6);
      const q = sample([2,3,4,5]);
      const p = sample([1,2,3]);
      const base = c ** q;
      const val = c ** p;
      return {
        q: `Evaluate $(${base})^{${p}/${q}}$.`,
        answer: `$${val}$`
      };
    }
    
    // NR2: Evaluate (perfect-power)^{-p/q}
    function genNR_U2_RationalExpNegative(){
      const c = ri(2, 6);
      const q = sample([2,3,4,5]);
      const p = sample([1,2,3]);
      const base = c ** q;
      const valN = c ** p;
      return {
        q: `Evaluate $(${base})^{-\\,${p}/${q}}$.`,
        answer: `$\\dfrac{1}{${valN}}$`
      };
    }
    
    // NR3: (a√ó10^m) + (b√ó10^n)  ‚Üí scientific notation
    function genNR_U2_SciAdd(){
      const a = (ri(12,95)/10);       // 1.2‚Äì9.5
      const b = (ri(12,95)/10);       // 1.2‚Äì9.5
      const m = ri(4,7), n = m + sample([-2,-1,0,1]); // keep close for nice sums
      const sum = a * (10**m) + b * (10**n);
      // convert to mantissa√ó10^E
      const E0 = Math.floor(Math.log10(sum));
      const M0 = sum / (10**E0);
      const { M, E } = normSci(M0, E0);
      return {
        q: `Compute $(${a.toFixed(2)}\\times 10^{${m}})+(${b.toFixed(2)}\\times 10^{${n}})$ in scientific notation.`,
        answer: `$${M.toFixed(2)}\\times 10^{${E}}$`
      };
    }
    
    // NR4: (a√ó10^m) / (b√ó10^n)  ‚Üí scientific notation
    function genNR_U2_SciDivide(){
      const a = (ri(11,99)/10);   // 1.1‚Äì9.9
      const b = (ri(12,95)/10);   // 1.2‚Äì9.5
      const m = ri(-6,6);
      const n = ri(-6,6);
      const mant = a / b;
      const exp = m - n;
      const { M, E } = normSci(mant, exp);
      return {
        q: `Compute $\\dfrac{${a.toFixed(1)}\\times 10^{${m}}}{${b.toFixed(1)}\\times 10^{${n}}}$ in scientific notation.`,
        answer: `$${M.toFixed(2)}\\times 10^{${E}}$`
      };
    }
    
    // NR5: Exponent equation in base 2 ‚Üí solve for x
    function genNR_U2_SolveExponentEquation(){
      const x = ri(2,10);
      const K = 3*x + 4; // from (2^{x-1})(2^{2x+5})=2^{3x+4}
      return {
        q: `If $(2^{x-1})(2^{2x+5})=2^{${K}}$, find $x$.`,
        answer: `$${x}$`
      };
    }
    
    // NR6: Compound sci-notation with powers, then division
    function genNR_U2_SciCompound(){
      // ((p√ó10^r)^2) / (q√ó10^s), choose so mantissa is clean
      const p = sample([3,4,5,6,7,8,9]);
      const q = sample([3,6,12]); // choose a divisor of p^2 to keep tidy
      const r = ri(-3,2), s = ri(-5,3);
      const mant = (p**2)/q;
      const exp  = 2*r - s;
      const { M, E } = normSci(mant, exp);
      return {
        q: `Evaluate $\\dfrac{(${p}\\times 10^{${r}})^{2}}{${q}\\times 10^{${s}}}$ in scientific notation.`,
        answer: `$${M.toFixed(2)}\\times 10^{${E}}$`
      };
    }

    // ---------- Unit 2: Written Response Generators ----------

    // ---------- Unit 2: Written Response Generators ----------

    // WR1: Simplify a monomial quotient (positive exponents in final)
    function genWR_U2_SimplifyMonomialQuotient(){
      // choose coefficients with clean reduction
      const c1 = 3 * ri(2,6), c2 = 3 * ri(1,4);  // multiples of 3
      const ax = ri(1,5), ay = -ri(0,4);
      const bx = -ri(0,3), by = ri(2,6);
      const q = `
    Simplify completely:
    $\\displaystyle \\frac{${c1}x^{${ax}}y^{${ay}}}{${c2}x^{${bx}}y^{${by}}}.$`;
      const coeff = c1 / c2;
      const xE = ax - bx, yE = ay - by;
      const numParts = [coeff!==1?`${coeff}`:'', xE>0?`x^{${xE}}`:'', yE>0?`y^{${yE}}`:''].filter(Boolean).join('');
      const denParts = [xE<0?`x^{${-xE}}`:'', yE<0?`y^{${-yE}}`:''].filter(Boolean).join('');
      const simplified = denParts ? `\\dfrac{${numParts||'1'}}{${denParts}}` : (numParts||'1');
      return {
        q: q.trim(),
        answer: `$${simplified}$`
      };
    }
    
    // WR2: Scientific notation product with rule explanation
    function genWR_U2_SciProductExplain(){
      const A = (ri(12,95)/10), B = (ri(12,95)/10);
      const m = ri(3,7), n = ri(2,6);
      let M = A*B, E = m+n;
      const pre = `${(A*B).toFixed(2)}\\times 10^{${E}}`;
      while(M>=10){ M/=10; E++; }
      const final = `${M.toFixed(2)}\\times 10^{${E}}`;
      return {
        q: `Write the product in scientific notation and name the exponent rule used:
    $(${A.toFixed(2)}\\times 10^{${m}})(${B.toFixed(2)}\\times 10^{${n}})$.`,
        answer: `$${pre}= ${final}\\,$ using $(a\\cdot10^{m})(b\\cdot10^{n})=(ab)\\cdot10^{m+n}$ and normalization to $[1,10)$.`
      };
    }
    
    // WR3: Rewrite fractional powers using radicals (x,y >= 0)
    function genWR_U2_FracPowersToRadicals(){
      const ax = ri(5,8), bx = ri(4,6);
      const ay = ri(4,6), by = ri(3,5);
      const q = `Rewrite using radicals and simplify (assume $x,y\\ge 0$):
    $\\;x^{${ax}/${bx}}\\;y^{${ay}/${by}}.$`;
      function split(n,d){
        const out = Math.floor(n/d), rem = n%d;
        const outStr = out? `x^{${out}}` : '';
        const inStr  = rem? `\\sqrt[${d}]{x^{${rem}}}` : '';
        return {outStr,inStr};
      }
      const Xo = Math.floor(ax/bx), Xr = ax%bx;
      const Yo = Math.floor(ay/by), Yr = ay%by;
      const outParts = [Xo?`x^{${Xo}}`:'' , Yo?`y^{${Yo}}`:''].filter(Boolean).join('');
      const inPieces = [];
      if (Xr) inPieces.push(`x^{${Xr}}`);
      if (Yr) inPieces.push(`y^{${Yr}}`);
      const rad =
        Xr && Yr && bx===by
          ? `\\sqrt[${bx}]{${inPieces.join('\\,')}}`
          : [Xr?`\\sqrt[${bx}]{x^{${Xr}}}`:'', Yr?`\\sqrt[${by}]{y^{${Yr}}}`:''].filter(Boolean).join('\\,');
      const ans = `${outParts}${rad}`;
      return {
        q,
        answer: `$${ans || '1'}$`
      };
    }
    
    // WR4: Simplify (perfects)^(1/k), variables nonnegative
    function genWR_U2_RootOfPerfects(){
      const coef = [16,36,81,144][ri(0,3)];
      const ax= ri(6,12), ay= ri(4,10), k = sample([2,3,4]);
      const q = `Simplify $(${coef}\\,x^{${ax}}y^{${ay}})^{1/${k}}$ for $x,y\\ge 0$.`;
      const outC = Math.round(coef ** (1/k));
      const xo = Math.floor(ax/k), xr = ax%k;
      const yo = Math.floor(ay/k), yr = ay%k;
      const outside = [outC>1?`${outC}`:'', xo?`x^{${xo}}`:'', yo?`y^{${yo}}`:''].filter(Boolean).join('');
      const inside = [xr?`x^{${xr}}`:'', yr?`y^{${yr}}`:''].filter(Boolean).join('\\,');
      const radical = inside? `\\sqrt[${k}]{${inside}}` : '';
      return {
        q,
        answer: `$${outside}${radical}$`
      };
    }
    
    // WR5: Order three numbers given as decimals/sci-notation mix
    function genWR_U2_OrderNumbers(){
      // Make two equal forms and one distinct larger/smaller
      const a = (ri(31,45))/100000;       // e.g., 0.00031 ‚Ä¶ 0.00045
      const b = a;                         // equal value in different form
      const c = a * ri(8,12);              // a scaled comparator
      const aTex = `${a}`;                 // decimal
      const bTex = `${(a*1e5).toFixed(2)}\\times 10^{-5}`; // sci notation equivalent
      const cTex = `${(c/Math.pow(10, Math.floor(Math.log10(c)))) .toFixed(2)}\\times 10^{${Math.floor(Math.log10(c))}}`;
      const q = `Order from least to greatest: $${aTex}$, $${bTex}$, $${cTex}$.`;
      const vals = [a, a, c].slice().sort((x,y)=>x-y);
      const leastToGreatest =
        a<=c ? `${aTex},\\ ${bTex},\\ ${cTex}` : `${cTex},\\ ${aTex},\\ ${bTex}`;
      return {
        q,
        answer: `Convert to decimals: $${aTex}= ${a},\\ ${bTex}= ${a},\\ ${cTex}= ${c.toExponential()}$.\\\\ Least to greatest: ${leastToGreatest}.`
      };
    }
    
    // WR6: Solve t^{3/2} = N sqrt(t)
    function genWR_U2_SolveRationalExponentEq(){
      const N = sample([9,16,25,27,36,49]);
      return {
        q: `Solve for $t>0$: $t^{3/2}=${N}\\sqrt{t}$.`,
        answer: `Divide by $t^{1/2}$ (since $t>0$): $t=${N}$.`
      };
    }
    
    // WR7: Area from diameter in scientific notation
    function genWR_U2_MicroArea(){
      const d = (ri(18,30)/10).toFixed(1); // e.g., 2.4 -> 2.4√ó10^{-6} m
      const q = `A bacterium has diameter $${d}\\times 10^{-6}\\text{ m}$. Using $\\pi\\approx 3.14$, express the area of its circular cross-section in scientific notation.`;
      const r = (parseFloat(d)/2);
      const areaMant = 3.14 * (r*r);
      // normalize
      let M = areaMant, E = -12; // (10^{-6})^2
      while(M>=10){ M/=10; E++; }
      while(M<1){ M*=10; E--; }
      return {
        q,
        answer: `$A=\\pi r^2\\approx 3.14\\,( ${(r).toFixed(2)}\\times 10^{-6})^{2} \\Rightarrow ${M.toFixed(2)}\\times 10^{${E}}\\text{ m}^2$.`
      };
    }
    
    // WR8: Fraction of powers like (27 a^{-3} b^6)^{1/3} / (3 a^{-1} b^2)^2
    function genWR_U2_SimplifyFracPowers(){
      const q = `Simplify
    $\\displaystyle \\frac{(27a^{-3}b^{6})^{1/3}}{(3a^{-1}b^{2})^{2}}\\quad (a,b\\ne 0).$`;
      return {
        q,
        answer: `Numerator $=3a^{-1}b^{2}$; denominator $=9a^{-2}b^{4}$. Thus $\\dfrac{3a^{-1}b^{2}}{9a^{-2}b^{4}}=\\dfrac{1}{3}\\,a^{1}b^{-2}=\\dfrac{a}{3b^{2}}$.`
      };
    }
    
    // WR9: Solve split-base exponential equation (randomized)
    // WR9 replacement: split-base exponential equation with clean signs & integer solution
    function genWR_U2_SolveSplitBases(){
      // Build: (2^a2 * 3^a3)^(Œ±x + Œ≤) = 2^(Œ≥x + Œ¥) * 3^(Œ∑x + Œ∏)
      const a2 = ri(1,3);          // exponent of 2 inside composite base
      const a3 = ri(1,3);          // exponent of 3 inside composite base
      const alpha = ri(1,3);       // coeff of x on LHS
      const beta  = ri(-3,3);      // constant on LHS (can be negative)
      const xStar = ri(1,6);       // force an integer solution
    
      // Choose Œ≥, Œ∑ distinct from a2*alpha, a3*alpha so it's non-trivial
      let gamma = ri(a2*alpha-3, a2*alpha+3);
      while (gamma === a2*alpha) gamma = ri(a2*alpha-3, a2*alpha+3);
    
      let eta = ri(a3*alpha-3, a3*alpha+3);
      while (eta === a3*alpha) eta = ri(a3*alpha-3, a3*alpha+3);
    
      // Pick Œ¥, Œ∏ to make x = xStar the exact solution:
      const delta = a2*(alpha*xStar + beta) - gamma*xStar;
      const theta = a3*(alpha*xStar + beta) - eta*xStar;
    
      // helper to format ¬± nicely in KaTeX: ax + b  (with proper minus sign)
      const lin = (coef, constant) => {
        const sign = constant >= 0 ? `+${constant}` : `${constant}`; // e.g., +5 or -7
        return `${coef}x${sign}`;
      };
    
      const baseCoef = `(2^{${a2}}\\cdot 3^{${a3}})`;
      const lhs = `${baseCoef}^{\\,${lin(alpha, beta)}}`;
      const rhs = `2^{${lin(gamma, delta)}}\\cdot 3^{${lin(eta, theta)}}`;
    
      const q = `$${lhs} = ${rhs}$. Solve for $x$.`;
    
      const ans =
    `Write ${baseCoef} as $2^{${a2}}3^{${a3}}$:
    \\[
    2^{${a2}(${lin(alpha,beta)})}3^{${a3}(${lin(alpha,beta)})}
    =2^{${lin(gamma,delta)}}3^{${lin(eta,theta)}}.
    \\]
    Equate exponents by base:
    \\( ${a2}(${lin(alpha,beta)}) = ${lin(gamma,delta)} \\) and
    \\( ${a3}(${lin(alpha,beta)}) = ${lin(eta,theta)} \\),
    both yielding $x=${xStar}$.`;
    
      return { q, answer: ans };
    }

    
    // WR10: Prime-power system for x,y (randomized but consistent)
    function genWR_U2_PrimePowerSystem(){
      // Choose prime-power exponents for x=2^a 3^b and y=2^c 3^d
      const a = ri(0,2), b = ri(0,2), c = ri(0,2), d = ri(0,2);
      // Avoid trivial x=y=1
      if (a+b+c+d === 0) return genWR_U2_PrimePowerSystem();
    
      const P = ri(2,4), Q = ri(2,4);   // exponents in first relation
      const R = ri(1,3);                // power of y in the second relation
    
      // Build target exponents for 2 and 3
      const A2 = P*a + Q*c, A3 = P*b + Q*d;     // x^P y^Q = 2^{A2} 3^{A3}
      const U2 = a - R*c,   U3 = b - R*d;       // x / y^R = 2^{U2} 3^{U3}
    
      const xVal = 2**a * 3**b;
      const yVal = 2**c * 3**d;
    
      const q =
    `If $x^{${P}}y^{${Q}}=2^{${A2}}3^{${A3}}$ and $\\dfrac{x}{y^{${R}}}=2^{${U2}}3^{${U3}}$, find $x$ and $y$ in prime-power form.`;
      const ans =
    `Let $x=2^{a}3^{b}$ and $y=2^{c}3^{d}$. Then
    $${P}a+${Q}c=${A2},\\ \\ ${P}b+${Q}d=${A3}$ and $a-${R}c=${U2},\\ \\ b-${R}d=${U3}$.
    Solving gives $a=${a},\\ b=${b},\\ c=${c},\\ d=${d}$.
    Thus $x=2^{${a}}3^{${b}}=${xVal}$ and $y=2^{${c}}3^{${d}}=${yVal}$.`;
      return { q, answer: ans };
    }
    
    // WR11: Power model y = a x^r via two points (randomized nice r)
    function genWR_U2_PowerModel(){
      // pick an integer exponent r between 1 and 3
      const r = ri(1,3);
      // choose integer base points for x
      const x1 = ri(2,4), x2 = ri(5,9);
      // pick a nice integer coefficient a
      const a = ri(1,4);
      // compute y values exactly
      const y1 = a * x1**r;
      const y2 = a * x2**r;
    
      const q = `The power model $y=ax^{r}$ passes through $(${x1},${y1})$ and $(${x2},${y2})$. Find $r$.`;
      const answer = `$r=${r}$ (since $\\dfrac{y_2/y_1}{(x_2/x_1)^r}=1$ confirms it)`;
    
      return { q, answer };
    }

    
    // WR12: Solve 2^{x+a}+2^{x} = 3^{y+b}-3^{y} (randomized pairs with integer solution)
    function genWR_U2_Diophantine1(){
      // Valid pairs so that 2^a+1 is a power of 3 and 3^b-1 is a power of 2:
      // (a,b) in {(1,1), (3,2)}
      const pair = sample([{a:1,b:1},{a:3,b:2}]);
      const a = pair.a, b = pair.b;
    
      // Then 2^x(2^a+1) = 3^y(3^b-1) => 3^{(log_3(2^a+1) - y)} = 2^{(log_2(3^b-1) - x)}
      // Integer solution occurs at x = log2(3^b - 1), y = log3(2^a + 1).
      const xSol = (b===1?1:3); // 3^1-1=2 -> x=1; 3^2-1=8 -> x=3
      const ySol = (a===1?1:2); // 2^1+1=3 -> y=1; 2^3+1=9 -> y=2
    
      const q = `Solve for integers $x,y$: $2^{x+${a}}+2^{x}=3^{y+${b}}-3^{y}$.`;
      const ans =
    `Factor: $2^{x}(2^{${a}}+1)$ and $3^{y}(3^{${b}}-1)$. Since $2^{${a}}+1=3^{${ySol}}$ and $3^{${b}}-1=2^{${xSol}}$,
    we have $3^{${ySol}}\\cdot 2^{x}=2^{${xSol}}\\cdot 3^{y}$, so $3^{${ySol}-y}=2^{${xSol}-x}$.
    Thus both exponents must be $0$: $x=${xSol}, $y=${ySol}.`;
      return { q, answer: ans };
    }
    
    // WR13: Composition identity f(x)=2^{kx+c} so f(x)f(m-x) is constant (randomized)
    function genWR_U2_CompositionIdentity(){
      const k = 2 * ri(2,5);           // even so c integer
      const m = ri(1,4);
      const c = -(k*m)/2;              // ensures kx+c + k(m-x)+c = 0
      const q = `If $f(x)=2^{${k}x${c>=0?'+':''}${c}}$, find $f(x)\\cdot f(${m}-x)$ in simplest form.`;
      const ans = `$2^{${k}x${c>=0?'+':''}${c}}\\cdot 2^{${k}(${m}-x)${c>=0?'+':''}${c}}=2^{${k}x+${c}+${k}m-${k}x+${c}}=2^{0}=1$.`;
      return { q, answer: ans };
    }
    
    // WR14: Mixed-base equation 3^{x+Œ±}+2^{x+Œ≤}+2^{x}=2^{x+Œ≥}+3^{x} with solution x=t (randomized)
    function genWR_U2_MixedBaseSolve(){
      // Two valid randomized families:
      // (t, Œ±, Œ≤, Œ≥) = (1,1,2,3)  -> A=3^Œ±-1=2^1, B=2^Œ≤+1-2^Œ≥ = -3^1
      // (t, Œ±, Œ≤, Œ≥) = (3,2,2,5)  -> A=3^Œ±-1=2^3, B=2^Œ≤+1-2^Œ≥ = -3^3
      const opt = sample([{t:1, alpha:1, beta:2, gamma:3}, {t:3, alpha:2, beta:2, gamma:5}]);
      const { t, alpha, beta, gamma } = opt;
    
      const q = `Solve: $3^{x+${alpha}}+2^{x+${beta}}+2^{x}=2^{x+${gamma}}+3^{x}$.`;
      const A = 3**alpha - 1;         // = 2^t
      const B = (2**beta) + 1 - (2**gamma); // = -3^t
      const check = `\\Rightarrow 3^{x}(${A}) + 2^{x}(${B})=0 \\Rightarrow \\left(\\tfrac{3}{2}\\right)^{x}=\\tfrac{-B}{A}=\\left(\\tfrac{3}{2}\\right)^{${t}}`;
    
      const ans = `${check} \\Rightarrow x=${t}.`;
      return { q, answer: ans };
    }





    

    document.getElementById('generate').addEventListener('click', renderQuiz);
    document.getElementById('toggleKey').addEventListener('click', (e)=>{
      const pressed=e.currentTarget.getAttribute('aria-pressed')==='true';
      e.currentTarget.setAttribute('aria-pressed', String(!pressed));
      e.currentTarget.textContent=pressed?'üß† Show Answers':'üôà Hide Answers';
      document.querySelectorAll('.ans').forEach(el=>{ el.toggleAttribute('hidden'); if(!el.hasAttribute('hidden')) typeset(el); });
    });
    document.getElementById('printBtn').addEventListener('click',()=>window.print());

    document.addEventListener('DOMContentLoaded', renderQuiz);
  </script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/katex.min.js"></script>
  <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.10/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body,{delimiters:[{left:'$$',right:'$$',display:true},{left:'$',right:'$',display:false},{left:'\\(',right:'\\)',display:false}],throwOnError:false});"></script>
</body>
</html>
